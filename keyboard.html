<style>
	.grid {
		display: grid;
		grid-template: repeat(3, 1fr) / repeat(4, 1fr);
		gap: 0.5em;
		width: 100%;
		height: 100%;
	}
	.key {
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		border-radius: 0.375em;
		font-size: 1.3em;
		color: white;
		overflow: hidden;
	}
	.key[data-index='0'],
	.key[data-index='2'],
	.key[data-index='3'],
	.key[data-index='4'] {
		border: medium solid #9a9494;
	}
	.key[data-index='6'],
	.key[data-index='8'],
	.key[data-index='9'],
	.key[data-index='10'] {
		border: medium solid #444;
	}
	.key[data-index='5'] {
		border: medium solid red;
	}
	.key[data-index='7'] {
		border: medium solid blue;
	}
	.key.pressed {
		border-color: #fff;
	}
	.key:empty {
		opacity: 0;
		pointer-events: none;
	}
	.key .top,
	.key .bottom {
		flex: 1;
		display: flex;
		align-items: center;
		justify-content: center;
	}
	.key .bottom {
		margin-bottom: 0.2em;
	}
	.key svg {
		width: 100%;
		height: 100%;
		object-fit: contain;
	}
</style>

<div class="grid"></div>

<script>
	(function () {
		const grid = document.querySelector('.grid');

		const svg = (paths = []) => {
			const p = paths.length
				? `<path stroke="#00f" stroke-width="10" d="${paths.join(
						''
				  )}" />`
				: '';
			return `<svg xmlns="http://www.w3.org/2000/svg" width="880" height="596" viewBox="0 0 880 596">
            <rect width="860" height="576" x="10" y="10" fill="none" stroke="#00f" stroke-width="10" rx="16"/>
            ${p}
        </svg>`;
		};

		const layoutSVG = [
			svg(),
			svg(['M440 10v576']),
			svg(['M10 298h860']),
			svg(['M440 10v576M440 298h430']),
			svg(['M10 298h860M440 298v288']),
			svg(['M440 10v576M10 298h430']),
			svg(['M10 298h860M440 10v288']),
		];
		const indices = {
			tab: 0,
			1: 2,
			2: 3,
			3: 4,
			q: 5,
			e: 7,
			w: 6,
			a: 8,
			s: 9,
			d: 10,
		};

		Object.entries(indices).forEach(([key, index]) => {
			const bind = pathless.keyboard()[key];
			if (bind) bind.index = index;
		});

		[null, 2, 3, 4, 0, 5, 6, 7, null, 8, 9, 10].forEach((i) => {
			const key = document.createElement('div');
			key.className = 'key';
			if (i !== null) {
				key.dataset.index = i;
				key.innerHTML =
					'<div class="top"></div><div class="bottom"></div>';
			}
			grid.appendChild(key);
		});

		let lastFocused = 0;
		let focusedKeys = new Set();

		const update = () => {
			const keyboard = pathless.keyboard();

			// Update all keys
			Object.entries(keyboard).forEach(
				([key, { onDown, onUp, pressed, index, global }]) => {
					if (index == null) return;
					const el = grid.querySelector(`[data-index='${index}']`);
					if (el) {
						const hasCallbacks = onDown !== null || onUp !== null;

						// Track non-global keys
						if (!global && hasCallbacks) {
							focusedKeys.add(key);
						}

						el.classList.toggle('pressed', pressed && hasCallbacks);
						el.querySelector('.top').textContent = hasCallbacks
							? key.toUpperCase()
							: '';
					}
				}
			);

			// Clear w/a/s/d keys that aren't in focused space
			Object.keys(indices).forEach((key) => {
				const bind = keyboard[key];
				const index = indices[key];
				const el = grid.querySelector(`[data-index='${index}']`);
				if (
					el &&
					(!bind || (bind.onDown === null && bind.onUp === null))
				) {
					el.classList.remove('pressed');
					el.querySelector('.top').textContent = '';
					focusedKeys.delete(key);
				}
			});
		};

		window.addEventListener('input', update);
		window.addEventListener('sync', () => {
			// Clear tracked keys on sync
			focusedKeys.clear();
			update();
		});
		update();
	})();
</script>
