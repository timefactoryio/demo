<style>
	#overlay {
		position: fixed;
		bottom: 1em;
		right: 1em;
		min-width: 20%;
		height: 30%;
		z-index: 1000;
		pointer-events: none;
	}
	#overlay.hidden {
		display: none;
	}
	#overlay .grid {
		display: grid;
		grid-template: 0.3fr 1fr 1fr 1fr / repeat(3, 1fr);
		gap: 0.5em;
		width: 100%;
		height: 100%;
		font-size: 1.3em;
		color: white;
		background: black;
		transition: grid-template 50ms;
	}
	#overlay .grid.no-tab {
		grid-template: repeat(3, 1fr) / repeat(3, 1fr);
	}
	#overlay .key {
		display: flex;
		flex-direction: column;
		border-radius: 0.375em;
		border: medium solid #444;
		overflow: hidden;
	}
	#overlay .key.tab {
		grid-column: 1 / -1;
		justify-content: center;
		align-items: center;
	}
	#overlay .key.hidden {
		display: none;
	}
	#overlay .key:empty {
		opacity: 0;
		pointer-events: none;
	}
	#overlay .top {
		flex: 0 0 40%;
		display: flex;
		align-items: center;
		justify-content: center;
	}
	#overlay .bottom {
		flex: 0 0 60%;
		display: flex;
		align-items: center;
		justify-content: center;
		box-sizing: border-box;
	}
	#overlay .bottom svg {
		padding: 0.3em;
		display: block;
		width: auto;
		height: 100%;
		max-width: 100%;
	}
	#overlay .key.pressed {
		border-color: white !important;
	}
</style>

<div class="grid"></div>

<script>
	if (!window.Keyboard) {
		class Keyboard {
			constructor(container) {
				this.container =
					container || document.querySelector('#overlay');
				this.grid = this.container.querySelector('.grid');
				this.keys = {};
				this.tabVisible = false;
				this.init();
			}

			createKey(name) {
				const el = document.createElement('div');
				el.classList.add('key');
				const isTab = name === 'tab';

				if (isTab) {
					el.classList.add('tab', 'hidden');
					el.textContent =
						name.charAt(0).toUpperCase() + name.slice(1);
				} else {
					el.innerHTML =
						'<div class="top"></div><div class="bottom"></div>';
					el.querySelector('.top').textContent = name.toUpperCase();
				}
				return {
					el,
					svgs: [],
					state: 0,
					bottom: isTab ? el : el.querySelector('.bottom'),
				};
			}

			createSvg(d) {
				const svg = document.createElementNS(
					'http://www.w3.org/2000/svg',
					'svg'
				);
				svg.setAttribute('viewBox', '0 0 880 596');
				svg.innerHTML = `<rect width="860" height="576" x="10" y="10" fill="none" stroke="#00f" stroke-width="30" rx="16"/>${
					d ? `<path stroke="#00f" stroke-width="30" d="${d}"/>` : ''
				}`;
				return svg;
			}

			init() {
				if (!this.grid) return;
				window.addEventListener('input', (e) =>
					this.handleInput(e.detail)
				);

				['tab', '1', '2', '3', 'q', 'w', 'e', 'a', 's', 'd'].forEach(
					(name) => {
						const key = this.createKey(name);
						this.keys[name] = key;
						this.grid.appendChild(key.el);
					}
				);

				this.grid.classList.add('no-tab');

				this.keys['1'].svgs = [
					'',
					'M440 10v576',
					'M10 298h860',
					'M440 10v576M440 298h430',
					'M10 298h860M440 298v288',
					'M440 10v576M10 298h430',
					'M10 298h860M440 10v288',
				];
				this.keys['2'].svgs = ['M440 10v576', 'M10 298h860'];
				this.keys['3'].svgs = [
					'M440 10v576M440 298h430',
					'M10 298h860M440 298v288',
					'M440 10v576M10 298h430',
					'M10 298h860M440 10v288',
				];

				for (const key of Object.values(this.keys)) {
					if (key.svgs.length) {
						key.bottom.appendChild(this.createSvg(key.svgs[0]));
					}
				}

				this.setColor('q', 'red');
				this.setColor('e', 'blue');
				['w', 'a', 's', 'd'].forEach((k) => this.setColor(k, 'grey'));
				this.set('q', 'prev');
				this.set('e', 'next');
			}

			handleInput(detail) {
				const { key, pressed } = detail;
				const keyObj = this.keys[key];
				if (!keyObj) return;
				keyObj.el.classList.toggle('pressed', pressed);
			}

			sync(layout, prevLayout) {
				this.tabVisible = layout[0] > 0;
				this.showTab();

				if (this.keys['1']) {
					this.keys['1'].state = 0;
				}

				if (this.keys['2']) {
					if (layout[0] === 1) {
						this.keys['2'].state = (layout[1] + 1) % 2;
					} else {
						this.keys['2'].state = 0;
					}
				}

				if (this.keys['3']) {
					if (layout[0] === 2) {
						this.keys['3'].state = (layout[1] + 1) % 4;
					} else {
						this.keys['3'].state = 0;
					}
				}

				['1', '2', '3'].forEach((k) => {
					const key = this.keys[k];
					if (key?.svgs) {
						const svg = key.svgs[key.state];
						key.bottom.replaceChildren(this.createSvg(svg || ''));
					}
				});
			}

			get(name) {
				return this.keys[name];
			}

			set(name, content) {
				const key = this.keys[name];
				if (key?.bottom) key.bottom.textContent = content || '';
			}

			setColor(name, color) {
				const key = this.keys[name];
				if (key) key.el.style.borderColor = color;
			}

			showTab() {
				this.keys['tab']?.el.classList.toggle(
					'hidden',
					!this.tabVisible
				);
				this.grid?.classList.toggle('no-tab', !this.tabVisible);
			}

			cycleSvg(name) {
				const key = this.keys[name];
				if (key?.svgs?.length) {
					key.state = (key.state + 1) % key.svgs.length;
					key.bottom.replaceChildren(
						this.createSvg(key.svgs[key.state])
					);
				}
			}
		}
		window.Keyboard = Keyboard;
	}

	if (!window.keyboard) {
		window.keyboard = new window.Keyboard();
	}
</script>
