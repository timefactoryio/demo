<style>
	#overlay {
		position: fixed;
		bottom: 1em;
		right: 1em;
		min-width: 20%;
		height: 30%;
		z-index: 1000;
		pointer-events: none;
		display: none;
	}
	#overlay.visible {
		display: block;
	}
	#overlay .grid {
		display: grid;
		grid-template: repeat(3, 1fr) / repeat(3, 1fr);
		gap: 0.3em;
		width: 100%;
		height: 100%;
		font-size: 1.3em;
		background: black;
	}
	#overlay .key {
		display: flex;
		flex-direction: column;
		border-radius: 0.375em;
		border: medium solid #444;
		overflow: hidden;
	}
	#overlay .top {
		flex: 0 0 40%;
		display: flex;
		align-items: center;
		justify-content: center;
	}
	#overlay .bottom {
		flex: 0 0 60%;
		display: flex;
		align-items: center;
		justify-content: center;
		box-sizing: border-box;
	}
	#overlay .bottom svg {
		padding: 0.3em;
		display: block;
		width: auto;
		height: 100%;
		max-width: 100%;
	}
	#overlay .key.pressed {
		border-color: white !important;
	}
</style>

<script>
	class Keyboard {
		constructor() {
			// Create overlay element if it doesn't exist
			this.container = document.getElementById('overlay');
			if (!this.container) {
				this.container = document.createElement('div');
				this.container.id = 'overlay';
				document.body.appendChild(this.container);
			}

			// Create grid
			this.grid = this.container.querySelector('.grid');
			if (!this.grid) {
				this.grid = document.createElement('div');
				this.grid.classList.add('grid');
				this.container.appendChild(this.grid);
			}

			this.keys = {};
			this.config = {
				layouts: {
					1: [''],
					2: ['M440 10v576', 'M10 298h860'],
					3: [
						'M440 10v576M440 298h430',
						'M10 298h860M440 298v288',
						'M440 10v576M10 298h430',
						'M10 298h860M440 10v288',
					],
				},
				actions: {
					q: { label: 'prev', color: 'red' },
					e: { label: 'next', color: 'blue' },
				},
			};
			this.init();
		}

		createKey(name) {
			const el = document.createElement('div');
			el.classList.add('key');
			el.innerHTML = `<div class="top">${name.toUpperCase()}</div><div class="bottom"></div>`;

			return {
				el,
				svgs: [],
				bottom: el.lastElementChild,
			};
		}

		createSvg(d) {
			const svg = document.createElementNS(
				'http://www.w3.org/2000/svg',
				'svg'
			);
			svg.setAttribute('viewBox', '0 0 880 596');
			svg.innerHTML = `
                <rect width="860" height="576" x="10" y="10" fill="none" stroke="#00f" stroke-width="30" rx="16"/>
                ${d ? `<path stroke="#00f" stroke-width="30" d="${d}"/>` : ''}
            `;
			return svg;
		}

		getNextState(key, layout) {
			const n = parseInt(key);
			if (n === 1) return 0;
			return layout[0] === n - 1
				? (layout[1] + 1) % this.keys[key].svgs.length
				: 0;
		}

		handleInput(key, pressed) {
			this.keys[key]?.el.classList.toggle('pressed', pressed);
		}

		init() {
			// Create all keys
			['1', '2', '3', 'q', 'w', 'e', 'a', 's', 'd'].forEach((name) => {
				this.keys[name] = this.createKey(name);
				this.grid.appendChild(this.keys[name].el);
			});

			// Configure layout keys with SVGs from config
			['1', '2', '3'].forEach((k) => {
				this.keys[k].svgs = this.config.layouts[k];
				this.keys[k].bottom.appendChild(
					this.createSvg(this.keys[k].svgs[0])
				);
			});

			// Configure action keys from config
			Object.entries(this.config.actions).forEach(
				([key, { label, color }]) => {
					this.set(key, label, color);
				}
			);
		}

		sync(layout) {
			['1', '2', '3'].forEach((k) => {
				const state = this.getNextState(k, layout);
				this.keys[k].bottom.replaceChildren(
					this.createSvg(this.keys[k].svgs[state])
				);
			});
		}

		set(name, content, color) {
			const key = this.keys[name];
			if (!key) return;
			key.bottom.textContent = content;
			if (color) key.el.style.borderColor = color;
		}
	}

	window.Keyboard = Keyboard;
</script>

<!-- <style>
	#overlay {
		position: fixed;
		bottom: 1em;
		right: 1em;
		min-width: 20%;
		height: 30%;
		z-index: 1000;
		pointer-events: none;
	}
	#overlay.hidden {
		display: none;
	}
	#overlay .grid {
		display: grid;
		grid-template: 0.3fr 1fr 1fr 1fr / repeat(3, 1fr);
		gap: 0.5em;
		width: 100%;
		height: 100%;
		font-size: 1.3em;
		color: white;
		background: black;
		transition: grid-template 50ms;
	}
	#overlay .grid.no-tab {
		grid-template: repeat(3, 1fr) / repeat(3, 1fr);
	}
	#overlay .key {
		display: flex;
		flex-direction: column;
		border-radius: 0.375em;
		border: medium solid #444;
		overflow: hidden;
	}
	#overlay .key.tab {
		grid-column: 1 / -1;
		justify-content: center;
		align-items: center;
	}
	#overlay .key.hidden {
		display: none;
	}
	#overlay .key:empty {
		opacity: 0;
		pointer-events: none;
	}
	#overlay .top {
		flex: 0 0 40%;
		display: flex;
		align-items: center;
		justify-content: center;
	}
	#overlay .bottom {
		flex: 0 0 60%;
		display: flex;
		align-items: center;
		justify-content: center;
		box-sizing: border-box;
	}
	#overlay .bottom svg {
		padding: 0.3em;
		display: block;
		width: auto;
		height: 100%;
		max-width: 100%;
	}
	#overlay .key.pressed {
		border-color: white !important;
	}
</style>

<div class="grid"></div>

<script>
	if (!window.Keyboard) {
		class Keyboard {
			constructor() {
				this.container = document.querySelector('#overlay');
				this.grid = this.container?.querySelector('.grid');
				this.keys = {};
				if (this.grid) this.init();
			}

			createKey(name) {
				const el = document.createElement('div');
				el.classList.add('key');

				if (name === 'tab') {
					el.classList.add('tab', 'hidden');
					el.textContent = 'Tab';
					return { el, svgs: [], bottom: el };
				}

				el.innerHTML = `<div class="top">${name.toUpperCase()}</div><div class="bottom"></div>`;
				return { el, svgs: [], bottom: el.lastElementChild };
			}

			createSvg(d) {
				const svg = document.createElementNS(
					'http://www.w3.org/2000/svg',
					'svg'
				);
				svg.setAttribute('viewBox', '0 0 880 596');
				svg.innerHTML =
					'<rect width="860" height="576" x="10" y="10" fill="none" stroke="#00f" stroke-width="30" rx="16"/>' +
					(d
						? `<path stroke="#00f" stroke-width="30" d="${d}"/>`
						: '');
				return svg;
			}

			getNextState(key, layout) {
				const n = parseInt(key);
				if (n === 1) return 0;
				return layout[0] === n - 1
					? (layout[1] + 1) % this.keys[key].svgs.length
					: 0;
			}

			init() {
				window.addEventListener('input', (e) =>
					this.keys[e.detail.key]?.el.classList.toggle(
						'pressed',
						e.detail.pressed
					)
				);

				// Create all keys
				['tab', '1', '2', '3', 'q', 'w', 'e', 'a', 's', 'd'].forEach(
					(name) => {
						this.keys[name] = this.createKey(name);
						this.grid.appendChild(this.keys[name].el);
					}
				);

				// Configure layout keys with SVGs
				this.keys['1'].svgs = [''];
				this.keys['2'].svgs = ['M440 10v576', 'M10 298h860'];
				this.keys['3'].svgs = [
					'M440 10v576M440 298h430',
					'M10 298h860M440 298v288',
					'M440 10v576M10 298h430',
					'M10 298h860M440 10v288',
				];

				['1', '2', '3'].forEach((k) =>
					this.keys[k].bottom.appendChild(
						this.createSvg(this.keys[k].svgs[0])
					)
				);

				// Configure action keys
				this.set('q', 'prev', 'red');
				this.set('e', 'next', 'blue');

				this.grid.classList.add('no-tab');
			}

			sync(layout) {
				const visible = layout[0] > 0;
				this.keys['tab'].el.classList.toggle('hidden', !visible);
				this.grid.classList.toggle('no-tab', !visible);

				['1', '2', '3'].forEach((k) => {
					const state = this.getNextState(k, layout);
					this.keys[k].bottom.replaceChildren(
						this.createSvg(this.keys[k].svgs[state])
					);
				});
			}

			set(name, content, color) {
				const key = this.keys[name];
				if (!key) return;
				key.bottom.textContent = content;
				if (color) key.el.style.borderColor = color;
			}
		}
		window.Keyboard = Keyboard;
	}
	if (!window.keyboard) {
		window.keyboard = new window.Keyboard();
	}
</script> -->

<!-- <style>
	#overlay {
		position: fixed;
		bottom: 1em;
		right: 1em;
		min-width: 20%;
		height: 30%;
		z-index: 1000;
		pointer-events: none;
		display: none;
	}
	#overlay.visible {
		display: block;
	}
	#overlay .grid {
		display: grid;
		grid-template: repeat(3, 1fr) / repeat(3, 1fr);
		gap: 0.3em;
		width: 100%;
		height: 100%;
		font-size: 1.3em;
		background: black;
	}
	#overlay .key {
		display: flex;
		flex-direction: column;
		border-radius: 0.375em;
		border: medium solid #444;
		overflow: hidden;
	}
	#overlay .top {
		flex: 0 0 40%;
		display: flex;
		align-items: center;
		justify-content: center;
	}
	#overlay .bottom {
		flex: 0 0 60%;
		display: flex;
		align-items: center;
		justify-content: center;
		box-sizing: border-box;
	}
	#overlay .bottom svg {
		padding: 0.3em;
		display: block;
		width: auto;
		height: 100%;
		max-width: 100%;
	}
	#overlay .key.pressed {
		border-color: white !important;
	}
</style>

<script>
	class Keyboard {
		constructor() {
			// Create overlay element if it doesn't exist
			this.container = document.getElementById('overlay');
			if (!this.container) {
				this.container = document.createElement('div');
				this.container.id = 'overlay';
				document.body.appendChild(this.container);
			}

			// Create grid
			this.grid = this.container.querySelector('.grid');
			if (!this.grid) {
				this.grid = document.createElement('div');
				this.grid.classList.add('grid');
				this.container.appendChild(this.grid);
			}

			this.keys = {};
			this.config = {
				layouts: {
					1: [''],
					2: ['M440 10v576', 'M10 298h860'],
					3: [
						'M440 10v576M440 298h430',
						'M10 298h860M440 298v288',
						'M440 10v576M10 298h430',
						'M10 298h860M440 10v288',
					],
				},
				actions: {
					q: { label: 'prev', color: 'red' },
					e: { label: 'next', color: 'blue' },
				},
			};
			this.init();
		}

		createKey(name) {
			const el = document.createElement('div');
			el.classList.add('key');
			el.innerHTML = `<div class="top">${name.toUpperCase()}</div><div class="bottom"></div>`;

			return {
				el,
				svgs: [],
				bottom: el.lastElementChild,
			};
		}

		createSvg(d) {
			const svg = document.createElementNS(
				'http://www.w3.org/2000/svg',
				'svg'
			);
			svg.setAttribute('viewBox', '0 0 880 596');
			svg.innerHTML = `
                <rect width="860" height="576" x="10" y="10" fill="none" stroke="#00f" stroke-width="30" rx="16"/>
                ${d ? `<path stroke="#00f" stroke-width="30" d="${d}"/>` : ''}
            `;
			return svg;
		}

		getNextState(key, layout) {
			const n = parseInt(key);
			if (n === 1) return 0;
			return layout[0] === n - 1
				? (layout[1] + 1) % this.keys[key].svgs.length
				: 0;
		}

		handleInput(key, pressed) {
			this.keys[key]?.el.classList.toggle('pressed', pressed);
		}

		init() {
			// Create all keys
			['1', '2', '3', 'q', 'w', 'e', 'a', 's', 'd'].forEach((name) => {
				this.keys[name] = this.createKey(name);
				this.grid.appendChild(this.keys[name].el);
			});

			// Configure layout keys with SVGs from config
			['1', '2', '3'].forEach((k) => {
				this.keys[k].svgs = this.config.layouts[k];
				this.keys[k].bottom.appendChild(
					this.createSvg(this.keys[k].svgs[0])
				);
			});

			// Configure action keys from config
			Object.entries(this.config.actions).forEach(
				([key, { label, color }]) => {
					this.set(key, label, color);
				}
			);
		}

		sync(layout) {
			['1', '2', '3'].forEach((k) => {
				const state = this.getNextState(k, layout);
				this.keys[k].bottom.replaceChildren(
					this.createSvg(this.keys[k].svgs[state])
				);
			});
		}

		set(name, content, color) {
			const key = this.keys[name];
			if (!key) return;
			key.bottom.textContent = content;
			if (color) key.el.style.borderColor = color;
		}
	}

	window.Keyboard = Keyboard;
</script> -->
